# 1주차 주제

## ✨ 자바스크립트란

자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로, 웹 브라우저에서 동작하는 유일한 프로그래밍 언어입니다.
보통은 개발자도구 콘솔에서 스크립트를 작성해 실행하기 때문에 개발자가 별도로 `컴파일` 할 필요하지 않아 `인터프리터 언어`라고 합니다.
하지만 자바스크립트엔진 내부에서 코드 실행 도중 컴파일이 필요한 경우, `자바스크립트엔진` 내부에서 컴파일을 합니다.

또한 `메인 스레드`와 하나의 `콜 스택`으로 이루어져 있기 때문에 `싱글스레드 `기반의 프로그래밍 언어라고도 합니다.

## ✨ 인터프리터 언어

자바스크립트의 성능을 비약적으로 향상시킬 수 있었던 이유는 자바스크립트엔진 내부에서 컴파일 과정을 거치지 때문입니다.
우선 자바스크립트엔진이 실행할 자바스크립트 파일을 받은 후 원하는 데이터를 특정패턴이나 순서로 추출해서 가공하는 파싱 `parsing` 과정을 거치고,
프로그래밍 언어로 작성된 소스 코드의 `추상 구문 트리`를 구축하는 과정을 거칩니다.

#### 🔖 추상 구문 트리 AST: Abstrast Syntax Tree

> 🔥 정리 필요

### 인터프리터 vs 컴파일러

컴파일러 언어와 인터프리터 언어의 가장 큰 차이점은 프로그래밍 언어를 컴퓨터가 이해할 수 있는 기계어로 변환하는 과정인, 컴파일 `pre-processing` 의 유무입니다.
변환된 기계어는 고급 언어로 바로 인터프리팅 방식으로 실행한 것보다 빠릅니다.

#### 🔖 인터프리터

위키백과에 따르면, 인터프리터는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말합니다.
원시 코드를 기계어로 번역하는 컴파일러와 대비되는데, 인터프리터는 다음 과정 중 하나의 기능을 가진 프로그램입니다.

1. 소스 코드를 직접 실행한다.
2. 소스 코드를 효율적인 다른 중간 코드로 변환하고, 변환한 것을 바로 실행한다.
3. 인터프리터 시스템의 일부인 컴파일러가 만든, 미리 컴파일된 저장 코드의 실행을 호출한다.

즉, 고급 언어로 작성된 원시 코드의 명령어를 한번에 한 줄씩 읽어들여서 실행하는 프로그램이라고 합니다.

#### 🔖 컴파일러

위키백과에 따르면, 컴파일러는 특정 프로그래밍 언어로 쓰여 있는 문서를 다른 프로그래밍 언어로 옮기는 언어 번역 프로그램을 말합니다.
고급 프로그래밍 언어를 실행 프로그램으로 만들기 위해 저급 프로그래밍 언어로 바꾸는 데 사용됩니다.

컴파일러는 소스 프로그램을 읽어서 즉시 결과를 출력하는 인터프리터와 구분되지만,
현대에 들어서 많은 인터프리터가 JIT 컴파일 등의 기술로 실시간 컴파일을 수행하기 때문에 컴파일러와 인터프리터 사이의 기술적인 부분은 사라져가는 추세라 합니다.

---

## ✨ 자바스크립트엔진

자바스크립트엔진은 기존에 한정적인 용도로만 쓰이던 자바스크립트가 수행가능한 기능이 늘어나면서, 브라우저 상에서 기존보다 더 빠르게 동작하기 위해 자바스크립트의 코드를 이해하고 실행을 도와주는 인터프리터입니다.
브라우저마다 다른 엔진을 사용하는데 크롬의 V8엔진, 파이어폭스의 스파이더몽키, 사파리의 웹킷 등이 있습니다. 이 중 크롬의 V8엔진을 기준으로 알아봤습니다.

자바스크립트 엔진은 변수와 객체의 메모리 할당이 발생되는 `메모리 힙`과 코드가 실행될 때마다 `실행 컨텍스트`가 쌓이는 `콜 스택`으로 이루어져 있습니다.

### 실행 컨텍스트

ECMAScript 스펙에 따르면, 실행 컨텍스트는 자바스크립트엔진이 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라 정의합니다.
자바스크립트는 어떤 실행 컨텍스트가 활성화될 때 선언된 변수를 위로 끌어올리는 호이스팅작업을 하고,
외부 환경 정보를 구성하고, this값을 설정하는 this바인딩 등의 동작을 수행하면서 실행할 코드에 줄 환경정보를 모읍니다.
이러한 환경정보들을 모은 객체를 **실행 컨텍스트**라고 합니다.

동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트를 구성하고,
이러한 컨텍스트를 콜 스택에 쌓았다가 제일 상단에 쌓인 실행 컨텍스트(=지금 실행 중인 코드의 실행 컨텍스트) `running execution context` 와 관련된 코드를 실행하는 방식으로 전체 코드의 환경과 순서를 보장합니다.

> 컨텍스트란?

컨텍스트는 한글번역으로 문맥, 맥락이라는 뜻으로, 위키백과에 따르면 보통은 사건 주변의 프레임이며 적절한 해석을 위해 자원을 제공한다고 합니다.
즉, 자바스크립트엔진이 개발자가 작성한 코드를 이해하기 위한 자원이라 볼 수 있습니다.

> 실행 컨텍스트의 필요성

코드가 실행될 때 전역인지 함수 내부인지 등의 스코프를 구분해서 ~~스코프에 등록된~~ 식별자와 바인딩된 값이 관리되어야 합니다.
또한 중첩 관계에 의해 스코프 체인을 만들어서 상위 스코프에 등록된 식별자를 검색해야하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색이 가능이 가능해야 합니다.
함수 호출이 종료되면 ~~함수 호출로 인해 실행이 멈췄던~~ 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행 되었던 코드를 구분해서 관리해야 합니다.

실행 컨텍스트는 스코프, 식별자, 코드 실행 순서 등의 관리를 해주고, 이러한 특징때문에 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다고 볼 수 있습니다.

> 실행 컨텍스트의 구성요소

실행 컨텍스트는 `렉시컬환경` 컴포넌트와 `환경변수` 컴포넌트로 구성됩니다.

실행 컨텍스트가 생성되는 초기에는 렉시컬환경을 참조해서 초기상태를 스냅샷처럼 정보를 저장한 환경변수를 만듭니다.
이후에 여러 상황을 만나면서 변경되는 정보는 렉시컬환경만 활용하고, 이때부터 환경변수와 렉시컬환경은 내용이 달라지게 됩니다.
그래서 환경변수는 실행 컨텍스트가 초기에 생성되었을 때 스냅샷을 가지고 있고, 렉시컬환경은 변경사항이 실시간으로 반영된다고 합니다.

#### 🔖 렉시컬 환경: LexicalEnvironment

렉시컬환경은 식별자와 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조입니다.
콜 스택이 코드의 실행 순서를 관리한다면 렉시컬환경은 실행 컨텍스트 내부에서 스코프와 식별자를 관리합니다.

렉시컬환경은 먼저 key와 value를 가지는 객체 형태의 ~~전역스코프, 함수스코프, 블록스코프와 같은~~ 스코프를 생성합니다.
생성된 스코프에 식별자를 key로 등록하고, 식별자에 바인딩된 값을 관리합니다.

즉, 스코프를 구분해서 식별자를 구분하고 관리하는 저장소의 역할을 합니다.

> 렉시컬환경의 구성

렉시컬환경은 환경레코드 `Environment Recode` 와 외부 렉시컬 환경에 대한 참조 `Outer Lexical Environment Reference` 로 구성됩니다.

환경레코드는 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리합니다.
이렇게 관리되는 내용들은 ~~strict mode, eval 코드, try/catch문과 같은~~ 소스 코드의 타입에 따라 관리하는 내용이 달라집니다.

외부 렉시컬환경에 대한 참조는 해당 실행 컨텍스트를 생성한소스코드를 포함하는 상위코드의 외부 렉시컬환경인 상위 스코프를 말합니다.
외부 렉시컬환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인이 구현 가능합니다.

#### 🔖 환경변수: VariableEnvironment

> 🔥 정리필요

### 실행 컨텍스트와 콜 스택

자바스크립트는 싱글스레드 언어이기 때문에 한 번에 한가지 작업만 실행하게 됩니다.

자바스크립트엔진은 전역 코드를 평가할 때 전역 실행 컨텍스트를 생성하고, 함수가 호출되면 함수 코드를 평가하며 함수 실행 컨텍스트를 생성합니다.
이렇게 생성된 실행 컨텍스트는 스택 자료구조로 관리되는데 이러한 스택을 **실행 컨텍스트 스택** 혹은 **콜 스택**이라고 부릅니다.

함수가 선언되면 실행 컨텍스트가 생성되고, 선언된 함수가 호출되면 함수 실행 컨텍스트가 콜 스택에 쌓이면서 실행되고, 모든 코드가 실행되면 콜 스택에서 실행 컨텍스트가 제거됩니다.

#### 🔖 런타임 & 런타임환경

단어 자체를 한글로 번역하면 실행시간이라고 하고 컴퓨터 과학에서 컴퓨터 프로그램이 실행하고 있는 동안의 동작을 말합니다.
또한 런타임 환경은 컴퓨터가 실행되는 동안 프로세스나 프로그램을 위한 소프트웨어 서비스를 제공하는 ~~컴퓨터 환경을 소프트웨어로 구현한~~ 가상머신의 상태를 나타냅니다.

자바스크립트 런타임은 자바스크립트가 코드를 실행하고 있는 동안을 나타내고, 자바스크립트 런타임환경은 자바스크립트 실행을 위한 환경이라 할 수 있습니다.
앞서 말한 내용을 토대로 자바스크립트가 실행할 수 있는 런타임환경은 브라우저와 Node.js가 있다고 볼 수 있습니다.

브라우저 상에서 자바스크립트엔진을 활용해서 자바스크립트를 실행하기 때문에 자바스크립트엔진만으로 모든 것이 이루어지는 것이 아니라 브라우저가 제공하는 `WEB API` 또한 활용할 수 있게 됩니다.

---

## ✨ 싱글스레드

자바스크립트엔진이 하나의 메인 스레드와 하나의 콜 스택을 가지고 있기 때문에 자바스크립트는 싱글스레드 기반의 언어라고 합니다.

#### 🔖 스레드 thread

위키백과에 따르면, 프로그램 특히 프로세스 안에서 실행되는 흐름의 단위를 말합니다. 일반적으로 한 프로그램은 하나의 스레드를 가지고 있지만, 프로그램 환경에 따라 둘 이상의 스레드를 동시에 실행할 수 있다고 합니다.
즉, 스레드는 코드가 실행되는 흐름의 단위를 말하며 싱글스레드는 이러한 흐름이 하나고, 멀티스레드는 흐름이 두 개 이상입니다.

싱글스레드는 한 번에 하나의 작업만 수행이 가능하기 때문에 다른 작업이 중간에 끼어들 수도 없고, 기존에 수행하던 작업이 끝나야만 그 다음 작업을 수행할 수 있습니다.
즉, 자바스크립트 또한 현재 실행하고 있는 함수가 있을 땐 다른 작업을 할 수가 없고 작업중단 `블로킹`이 발생합니다.
브라우저에서 오래 걸리는 작업이 실행될 때 블로킹이 발생하면 웹 페이지의 UI는 멈춰버리고 사용자는 어떠한 행동도 할 수 없게 되고, 오랜 시간동안 응답이 없으면 브라우저는 에러를 일으키고 사용자에게 해당 페이지를 닫을지 물어봅니다.

이처럼 UI를 막지 않고 브라우저가 응답없음 상태에 빠지지 않게 하면서, 무거운 코드를 수행하기 위해 `WEB API` 같은 브라우저의 도움을 받아 WEB API의 도움을 받아 무작정 하나씩 순차적으로 실행하는 것이 아니라 효과적으로 시간을 분배하며 이벤트를 관리하는 `비동기콜백` 작업을 처리합니다.

#### 🔖 동기 vs 비동기

코드를 한번에 하나씩만 실행하는 방식을 **동기 처리**라 합니다.
동기 처리방식은 순서대로 하나씩 처리하기 때문에 실행 순서가 보장된다는 장점이 있지만, 선행되는 작업이 종료될 때까지 이후의 작업들이 블로킹되는 단점이 있습니다.

반대로 현재 하는 작업이 종료되지 않더라도 이후의 일들을 바로 실행하는 방식을 **비동기 처리**라 합니다.
비동기 처리방식은 블로킹이 발생하지 않는 장점이 있지만, 실행 순서가 보장되지 않는 단점이 있습니다.

---

## ✨ WEB API

자바스크립트엔진에서 제공해주지는 않지만 자바스크립트 개발자가 사용하는 `setTimeout`함수와 같이, 브라우저에서 제공하는 API를 말합니다.
그리고 이러한 WEB API의 호출을 제어하기 위해 `콜백 큐`와 `이벤트 루프`가 있습니다.

### 이벤트 루프

루프의 사전적인 의미는 반복, 순환인 만큼, 이벤트 루프는 계속 반복해서 콜 스택과 콜백 큐 사이의 작업을 확인하고, 콜 스택이 비워지면 큐에서 작업을 꺼내서 콜 스택에 넣습니다.
자바스크립트는 이벤트 루프와 콜백 큐들을 이용해서 비동기작업을 수행하는데 직접적인 수행은 WEB API에서 처리됩니다.
먼저 처리되도록 등록된 작업이 완료되면 비동기작업을 요청할 때 등록되었던 ~~나중에 처리할~~ 콜백이 콜백 큐에 등록되고, 이벤트 루프는 이러한 콜백작업을 큐에서 꺼내서 처리합니다.

#### 🔖 콜백 큐

자바스크립트 런타임환경에서 처리할 작업목록과 실행할 콜백함수의 리스트를 콜백 큐라고 합니다.

이벤트루프는 콜 스택에 처리할 작업이 없다면, 우선적으로 `마이크로 스택 큐` 를 확인합니다.
만약 `마이크로 스택 큐` 에 작업이 있다면 `마이크로스택`에 있는 작업을 꺼내서 콜 스택에 넣습니다.
만약 `마이크로 스택 큐` 이 비어서 더 이상 처리할 작업이 없다면, `테스크 큐` 를 확인합니다.
만약 `테스크 큐` 에 작업이 있다면 `테스크 큐` 의 작업도 꺼내서 콜 스택에 넣습니다.

이벤트 루프와 콜백 큐는 자바스크립트엔진이 하나의 코드 조각을 하나씩 처리할 수 있도록 작업을 스케쥴링하면서, 우리가 자바스크립트에서 비동기작업을 할 수 있게 해줍니다.

#### 🔖 자바스크립트의 비동기 작업 종류

1. 테스크: Task

테스크는 비동기 작업이 우리가 코드를 작성할 때 의도된 순서를 희망할 수 있게 순차적으로 수행할 수 있도록 보장하는 형태의 작업 유형입니다.
그렇다고 테스크 사이에는 브라우저 렌더링과 같은 작업이 발생할 수 있기 때문에 테스크 다음에 바로 테스크가 실행된다는 의미는 아닙니다.

2. 마이크로테스크: Microtask

마이크로테스크는 비동기 작업이 현재 실행되는 스크립트 바로 다음에 일어나는 작업이기 때문에 테스크보다 항상 먼저 실행됩니다.
대표적으로 `MutationObserver`와 `Promise` 가 있습니다.

---

## ✨ 소스코드의 평가와 실행 과정

모든 소스코드는 실행하기 전 평가를 하며 코드를 실행하기 위한 준비를 합니다.

먼저 평가를 할 땐, 환경정보가 담긴 객체형태의 실행 컨텍스트를 생성하고 변수, 함수같은 선언문만 먼저 실행합니다.
이렇게 생성된 변수나 함수 식별자를 key로, 실행 컨텍스트가 관리하는 ~~렉시컬환경의 환경변수인~~ 스코프에 등록합니다.

이러한 평가가 끝나면, 평가과정에서 실행한 선언문을 제외한 나머지 소스코드가 순서대로 실행되면서 런타임이 시작됩니다.
이때 코드의 실행에 변수나 함수의 참조같이 필요한 정보를 실행 컨텍스트가 관리하는 스코프에서 찾아서 실행하고, 실행한 결과는 다시 스코프에 등록됩니다.

만약 `var x = 1;` 라는 코드가 있을 때 자바스크립트엔진은 우선 평가과정에서 변수 선언을 하는 `var x;` 를 먼저 실행합니다.
이때 생성된 변수 식별자 x는 스코프에 등록되고 undefined로 초기화됩니다.

이러한 평가과정이 끝나면 비로소 실행과정이 시작되는데, `var x;`는 평가과정에서 이미 실행되었기 때문에 `x=1;` 부분만 실행됩니다.

만약 변수에 값을 할당하려면 먼저 변수 x가 선언된 변수인지 확인하고 값을 할당을 하게 됩니다.
변수 x가 선언되어서 스코프에 등록되어 있다면 값을 할당하고 할당 결과를 다시 스코프에 등록해 관리합니다.

### 1. 전역 코드의 평가

전역 코드를 실행하기 전, 전역 코드를 실행하기 위한 준비를 하기 위해 선언문만 먼저 실행합니다.
따라서 전역코드의 변수 선언문과 함수 선언문이 먼저 실행되고, 실행된 결과는 전역 스코프에 등록됩니다.
`var` 키워드로 선언된 전역변수와 `함수 선언문` 으로 정의된 전역 함수는 전역 객체의 `property` 와 `method` 가 됩니다.

#### 🔖 property

> 🔥 정리필요

#### 🔖 method

> 🔥 정리필요

### 2. 전역 코드의 실행

이전의 평가 과정이 끝나면 자바스크립트의 런타임이 시작되면서, 전역 실행 컨텍스트가 메인 스레드에서 실행되고 전역 코드가 순서대로 실행됩니다.
이때 평가과정에서 선언된 전역 변수에 값이 할당되고 함수가 호출됩니다.
함수가 호출되면, 순서대로 실행되던 전역 코드의 실행을 일시 중단하고 함수 내부에 진입하면서 코드의 실행 순서를 변경합니다.

> 참고

일부 책에서는 전역 코드에서나 함수 코드에서 실행될 때 각각 런타임이 시작된다고 하지만,
런타임은 프로그램이 종료될 때까지 계속 실행되기 때문에 전역이나 함수의 실행 컨텍스트가 메인스레드에서 실행된다고 보는 것이 좋습니다.

### 3. 함수 코드의 평가

전역에서 함수 호출에 의해 함수 내부로 진입하게 되면 마찬가지로, 평가과정을 거치며 함수 코드를 실행하기 위한 준비를 합니다.
이때 매개변수나 지역변수 선언문이 먼저 실행되고, 그렇게 생성된 매개변수와 지역변수는 지역스코프에 등록됩니다.

한편, 함수 내부에서도 지역변수처럼 사용할 수 있는 `arguments` 객체가 생성되서 지역 스코프에 등록되고 이에 따라 `this바인딩` 도 결정됩니다.

#### 🔖 parameter

> 🔥 정리필요

#### 🔖 arguments

> 🔥 정리필요

#### 🔖 바인딩이란?

> 🔥 정리필요

### 4. 함수 코드의 실행

함수코드의 평가과정이 끝나면 메인 스레드에서 실행되던 전역 실행 컨텍스트는 잠시 중단되고, 함수 실행 컨텍스트가 실행되면서 함수 내부의 코드가 실행됩니다.
이때 이미 선언된 매개변수와 지역변수에 값이 할당하고 메서드가 호출됩니다.

이때 메서드를 호출하기 위해 코드 실행에 필요한 식별자 등을 저장한, 스코프 체인에서 식별자를 검색합니다.

여기서는 메서드를 `console.log('콘솔로그')` 로 예시를 들어보겠습니다.
이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결이 되어야 하지만,
`console` 식별자 같은 경우 스코프에 등록된 것이 아니기 때문에 스코프 체인에 등록되어있지 않고 전역 객체에 `property` 로 존재합니다.

즉, 전역 객체의 property가 마치 전역 변수처럼 전역 스코프를 통해 검색이 가능해야 합니다.

그 다음 `log` property를 `console` 객체의 `프로토타입` 체인에서 검색하고 `console.log`메서드에 인수로 전달된 표현식이 평가됩니다.
이러한 식별자들은 해당 함수의 스코프에서 검색할 수 없기 때문에 스코프 체인에서 검색합니다.
이후에 `console.log` 메서드의 실행이 종료되면 함수 코드의 실행과정이 종료되고 함수를 호출하면서 멈췄던 전역 코드의 실행을 계속합니다.
