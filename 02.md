## ✨ Promise

프로미스는 현재 하는 작업이 종료되지 않더라도 이후의 일들을 바로 실행할 수 있는 비동기 처리가 가능합니다.
프로미스 생성자 함수는 비동기 처리를 할 콜백 함수를 인수로 전달받는데,
이 콜백함수는 또 두 개의 함수를 인자로 받아서 현재 하는 작업이 성공하면 resolve, 실패하면 reject함수를 호출합니다.

## ✨ 폴리필: polyfill

폴리필은 브라우저가 지원하지 않는 자바스크립트 코드를 지원할 수 있도록 변환하는 코드조각이나 플러그인을 말합니다.
하위 브라우저가 지원하는 자바스크립트 코드를 사용해서 자바스크립트의 최신 기능을 똑같이 구현하는 방식입니다.

트랜스파일러인 `바벨` 내부에는 **core-js 라이브러리**가 탑재되어있어서 모던 자바스크립트 코드를 구표준을 준수하는 코드로 바꿔주는 폴리필처리가 가능합니다.
이러한 폴리필처리를 통해 특정기능을 제공하지 않는 서로 다른 브라우저나 저 사양의 브라우저에서 정상적으로 코드가 작동되게 해주는 `크로싱 브라우징`이 가능합니다.

폴리필에는 브라우저에서 코드를 실행할 때 브라우저에서 실행이 가능한지 여부를 확인한 뒤 실행이 불가능할 때만 코드 변환을 하는 **런타임 기능 주입방식**으로 동작합니다.

#### 🔖 바벨

> 🔥 정리필요

#### 🔖 크로싱 브라우징

> 🔥 정리필요

## ✨ 클로저

클로저는 함수가 속한 렉시컬스코프를 기억해서 함수가 렉시컬스코프 바깥에서 실행될 때에도 이 스코프에 접근할 수 있게 해주는 기능입니다.
그래서 내부 함수에서 부모 함수의 스코프의 변수에 접근이 가능한데, 이는 부모함수가 이미 호출되서 반환했을 때에도 가능합니다.
따라서 이미 테스크 큐에서 부모 함수의 실행 컨텍스트의 정보는 모두 사라졌어도 자식함수가 남아있으면, 자식함수는 이미 실행이 종료된 부모함수의 실행 컨텍스트의 정보를 참조할 수 있습니다.

리액트 훅의 useState 메서드는 이러한 클로저의 특징을 활용해서 함수의 state상태를 기억합니다.

### 클로저를 활용한 리액트 훅의 구현방식

클래스 컴포넌트는 `render()` 메서드를 통해 상태 변경을 감지해, 필요한 부분만 업데이트가 가능하지만
함수형 컴포넌트는 렌더가 필요할 때마다 함수를 다시 호출하기 때문에 렌더링이 곧 함수호출이라고 할 수 있습니다.

이러한 관점에서 실제로 state와 setState를 사용하는 시점은 리액트 컴포넌트의 호출이 끝난뒤 (=렌더링이 끝난뒤)지만 클로저가 초기값을 기억하기 때문에 이후에도 접근이 가능합니다.

> 자세히

state는 변수이기 때문에 리액트 컴포넌트의 호출이 끝나면 반환되어 더 이상 변경할 수 없는 상태가 됩니다.
따라서 이후에 setState 메서드를 통해 state값을 useState 메서드 외부에 배열 형식으로 저장합니다.
순서대로 배열에 저장된 state들은 상태가 업데이트되었어도 리액트 컴포넌트 바깥에서 선언된 변수이기 때문에 클로저를 이용해 접근이 가능합니다.

이런 동작원리로 인해 리액트 훅을 사용할 땐 리액트 함수 내부의 최상위에서만 리액트 훅을 호출할 수 있는 사용규칙이 있는데,
선언된 상태들이 컴포넌트를 key로 하는 배열에 순서대로 저장되기 때문에 만약 리액트 훅을 조건문이나 일반 자바스크립트 함수 안에서 사용된다면
맨 처음 함수가 실행될 때 저장되었던 순서와 맞지 않게 엉뚱한 상태를 참조할 수 있기 때문입니다.

## ✨ MutationObserver

MutationObserver 생성자는 DOM요소가 변경여부를 감지할 수 있습니다.
뮤테이션옵저버 생성자에서 새로운 옵저버 객체를 만드는데, 이러한 옵저버 객체의 `observe()` 메서드를 통해 감시대상에 변경사항이 발생할 때마다 미리 정해둔 동작을 수행합니다.
`observe()` 메서드에는 첫 번째 인자로 감시대상을, 두 번째 인자로 어떤 것을 감지할 지에 대한 옵션을 넣어 설정할 수 있고, 옵저버 객체의 `disconnect()` 메서드를 사용해서 감시를 중단할 수 있습니다.

## ✨ globalThis

글로벌this가 가리키는 전역 객체는 클라이언트사이드환경인 브라우저에서는 `window`, 서버사이드환경인 Node.js에서는 `global` 객체를 의미합니다.
각 환경에 따라 사용가능한 API가 다르기 때문에 글로벌this가 달라집니다.

브라우저의 경우, 사용자에게 웹 페이지를 보여주는 것이 목적이기 때문에 HTML요소를 선택하고 조작하는 DOM API가 제공됩니다.
이러한 작업을 위해 `window, document` 객체에 접근이 가능합니다.

한편 Node.js에서는 주로 서버에서 데이터를 다루는 목적으로 사용되기 때문에 로컬스토리지에 파일을 생성하고 수정하는 파일시스템관련 API가 제공됩니다.
이러한 작업을 수행하기 위해 Node.js는 브라우저에 비해 컴퓨터의 깊숙한 곳까지 제어가 가능합니다.
만약 브라우저를 통해 파일을 조작한다면 보안적으로 매우 위험하기 때문에 브라우저 환경에서는 이러한 동작을 하지 않아 window객체에 접근이 불가능하고 대신 `global` 객체에 접근이 가능합니다.

## ✨ 서버사이드렌더링 SSR

서버사이드렌더링은 말 그대로 페이지가 새로고침될 때마다 서버쪽에서 렌더링 준비를 끝마친 상태로
클라이언트에게 전달해서 새로 렌더링하는 전통적인 브라우저 렌더링 방식입니다.

1. 유저가 웹 사이트 요청을 하면 서버는 리소스를 체크 및 컴파일한 뒤에 완성된 HTML 컨텐츠로 바로 렌더링이 가능한 HTML파일을 만듭니다.
2. 클라이언트에게 이러한 `Ready to Render` HTML 파일을 전달하는 순간, 이미 렌더링 준비가 되어있기 때문에 HTML은 즉시 렌더링됩니다.
   바로 렌더링되기 때문에 자바스크립트가 읽혀지기 전까지는 웹 사이트를 조작할 수 없습니다.
3. 클라이언트에서 자바스크립트를 다운받는 동안 유저는 컨텐츠는 볼 수 있지만, 아직 사이트를 조작할 수 없고 사용자의 조작만을 기억합니다.
4. 자바스크립트 다운이 완료되면 브라우저가 자바스크립트엔진을 실행합니다.
   자바스크립트를 성공적으로 컴파일하면 기억하고 있던 사용자의 조작이 실행되고 이제서야 웹 페이지는 상호작용이 가능해집니다.

> 렌더링이 완료되기 전까지 오래 걸리는 문제 해결

script파일을 body요소의 최 하단에 위치시키거나, script태그에 async속성을 부여하거나, 네트워크 리소스 블로킹을 통해 불필요한 무거운 파일들을 제한하는 방법으로 해결이 가능합니다.

#### 🔖 클라이언트사이드렌더링 CSR

전통적인 웹 방식인 페이지가 새로고침할 때마다 서버로부터 리소스를 받아 화면에 새로 렌더링하는 서버사이드렌더링이 있긴 하지만,
웹에서 제공하는 정보변화가 많아지면서 정보가 변동될 때마다 서버로부터 새로 리소스를 받아 렌더링을 하면 성능이슈가 발생합니다.
이러한 문제를 해결하기 위해 사용자의 행동에 따라 필요한 부분만 다시 렌더링이 가능한 클라이언트사이드렌더링이 등장했습니다.

서버사이드렌더링과는 다르게 클라이언트에서 렌더링이 발생합니다.
즉, 서버는 요청을 받으면 클라이언트에게 HTML와 자바스크립트 파일을 전달하고 클라이언트는 파일을 받아 렌더링을 시작합니다.

1. 유저가 웹 사이트 요청을 하면, 여러 지역으로 분산된 여러 개의 서버인 **컨텐츠 전송 네트워크 CDN** 중 물리적으로 가장 가까운 서버에서 HTML와 자바스크립트 파일로 접근이 가능한 링크를 클라이언트에게 전달합니다.
2. 클라이언트는 링크를 통해 HTML와 자바스크립트 파일을 다운받는 동안 유저는 아무것도 볼 수 없습니다.
3. 클라이언트가 파일을 모두 다운을 받으면 데이터를 위한 API를 호출하고, 그동안 유저는 placeholder를 보게 됩니다.
4. API에서 받은 데이터를 placeholder 자리에 넣고 이때부터 유저와의 상호작용이 가능해집니다.

> 단점과 문제점

클라이언트사이드렌더링에서 서버는 단지 JSON파일을 보내주는 역할을 할 뿐, HTML을 그리는 역할은 클라이언트에서 수행합니다.
하지만 클라이언트사이드렌더링은 자바스크립트가 모든 동작을 수행한 후, 화면에 내용이 나타나기 때문에 초기 구동속도는 서버사이드렌더링에 비해 느리다는 단점이 있습니다.
**검색엔진최적화 SEO**를 할 수도 없고, 보안적으로도 취약하다는 문제점이 있습니다.
